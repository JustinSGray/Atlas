# pylint: disable=line-too-long, invalid-name, bad-whitespace, trailing-whitespace, too-many-locals, line-too-long
# Partially autogenerated with SMOP version 0.22
# /OpenMDAO/dev/hschilli/latest/devenv/bin/smop lift_drag.m -o lift_drag.py
import math
import numpy as np

from openmdao.lib.datatypes.api import Int, Float, Array, VarTree
from openmdao.main.api import Component, VariableTree

class Fblade(VariableTree):
    Fx = Array(desc='')
    Fz = Array(desc='')
    My = Array(desc='')
    Q  = Array(desc='')
    P  = Array(desc='')
    Pi = Array(desc='')
    Pp = Array(desc='')


class liftDrag(Component):
    """
    Computes drag coefficient
    """

    Ns = Int(0, iotype='in', desc='description')
    rho = Float(0.0, iotype='in', desc='description')
    visc = Float(0.0, iotype='in', desc='description')
    vw = Float(0.0, iotype='in', desc='description')
    vc = Float(0.0, iotype='in', desc='description')
    Omega = Float(0.0, iotype='in', desc='description')
    r = Array( iotype='in', desc='description')
    t = Array( iotype='in', desc='description')
    vi = Array( iotype='in', desc='description')
    c = Array( iotype='in', desc='description')
    Cl = Array( iotype='in', desc='description')
    dr = Array( iotype='in', desc='description')
    d = Array( iotype='in', desc='description')
    yWire = Array( iotype='in', desc='description')
    zWire = Float(0.0, iotype='in', desc='description')
    yN = Array( iotype='in', desc='description')
    tWire = Float(0.0, iotype='in', desc='description')
    chordFrac = Array( iotype='in', desc='description')
    Cm = Array( iotype='in', desc='description')
    xtU = Array( iotype='in', desc='description')
   
    Re = Array( iotype='out', desc='description')
    Cd = Array( iotype='out', desc='description')
    phi = Array( iotype='out', desc='description')
    Fblade = VarTree(Fblade(), iotype='out', desc='')

    # overall outputs are
    # function [Fblade, vi, phi, Re, Cd, ring] = ...

    def execute(self):

        # Pre-allocate output arrays
        self.Re = np.zeros(self.Ns)
        self.Cd = np.zeros(self.Ns)
        self.phi = np.zeros(self.Ns)
        self.Fblade.Fx = np.zeros(self.Ns)
        self.Fblade.Fz = np.zeros(self.Ns)
        self.Fblade.My = np.zeros(self.Ns)
        self.Fblade.Q = np.zeros(self.Ns)
        self.Fblade.P = np.zeros(self.Ns)
        self.Fblade.Pi = np.zeros(self.Ns)
        self.Fblade.Pp = np.zeros(self.Ns)

        for s in range(1,(self.Ns+1)):
            U = math.sqrt((self.Omega * self.r[(s-1)] + self.vw) ** 2 + (self.vc + self.vi[(s-1)]) ** 2)
            if self.c[(s-1)] > 0.001:
                self.Re[(s-1)] = self.rho * U * self.c[(s-1)] / self.visc
                self.Cd[(s-1)] = self.dragCoefficientFit(self.Re[(s-1)],self.t[(s-1)],self.xtU[(s-1)],self.xtL[(s-1)])
                dL = 0.5 * self.rho * U ** 2 * self.Cl[(s-1)] * self.c[(s-1)] * self.dr[(s-1)]
                dD = 0.5 * self.rho * U ** 2 * self.Cd[(s-1)] * self.c[(s-1)] * self.dr[(s-1)]
            else:
                self.Re[(s-1)] = self.rho * U * self.d[(s-1)] / self.visc
                if self.Re < 3500:
                    self.Cd[(s-1)] = - 1e-10 * self.Re[(s-1)] ** 3 + 7e-07 * self.Re[(s-1)] ** 2 - 0.0013 * self.Re[(s-1)] + 1.7397
                else:
                    self.Cd[(s-1)] = 1
                dL = 0
                dD = 0.5 * self.rho * U ** 2 * self.Cd[(s-1)] * self.d[(s-1)] * self.dr[(s-1)]
            for w in range(1,(max(self.yWire.shape)+1)):
                if self.yN[(s-1)] < self.yWire[(w-1)]:
                    if self.yN[(s + 1-1)] < self.yWire[(w-1)]:
                        L = self.dr[(s-1)] * math.sqrt(self.zWire ** 2 + self.yWire[(w-1)] ** 2) / self.yWire[(w-1)]
                    else:
                        L = (self.yWire[(w-1)] - self.yN[(s-1)]) * math.sqrt(self.zWire ** 2 + self.yWire[(w-1)] ** 2) / self.yWire[(w-1)]
                    ReWire = self.rho * U * self.tWire / self.visc
                    CdWire = - 1e-10 * ReWire ** 3 + 7e-07 * ReWire ** 2 - 0.0013 * ReWire + 1.7397
                    dD = dD + 0.5 * self.rho * U ** 2 * CdWire * self.tWire * L
            self.phi[(s-1)] = math.atan2(self.vc + self.vi[(s-1)],self.vw + self.Omega * self.r[(s-1)])
            print "*" * 10
            print self.vc,self.vi[(s-1)], self.vw, self.Omega, self.r[(s-1)], self.phi[(s-1)]
            print "*" * 10
            self.Fblade.Fz[s-1] = self.chordFrac[(s-1)] * (dL * math.cos(self.phi[(s-1)]) - dD * math.sin(self.phi[(s-1)]))
            self.Fblade.Fx[s-1] = self.chordFrac[(s-1)] * (dD * math.cos(self.phi[(s-1)]) + dL * math.sin(self.phi[(s-1)]))
            self.Fblade.My[s-1] = self.chordFrac[(s-1)] * (0.5 * self.rho * U ** 2 * self.Cm[(s-1)] * self.c[(s-1)] * self.c[(s-1)] * self.dr[(s-1)])
            self.Fblade.Q[s-1] = self.Fblade.Fx[s-1] * self.r[(s-1)]
            self.Fblade.P[s-1] = self.Fblade.Q[s-1] * self.Omega
            self.Fblade.Pi[s-1] = self.chordFrac[(s-1)] * (dL * math.sin(self.phi[(s-1)]) * self.r[(s-1)] * self.Omega)
            self.Fblade.Pp[s-1] = self.chordFrac[(s-1)] * (dD * math.cos(self.phi[(s-1)]) * self.r[(s-1)] * self.Omega)
   


    def dragCoefficientFit(self, Re, t, xtU, xtL):
        """
        Computes drag coefficient
        dragCoefficient.m returns the drag coefficient of an airfoil at Reynolds
        number Re, with thickness to chord ratio tc, and with xtcU and xtcL
        fraction of laminar flow on the upper and lower surfaces respectively.
        The result if a fit on existing HPH airfoils.
        """

        Cf15_15 = 0.6798*Re**(-0.283)
        Cf60_100 = 22.09*Re**(-0.604)
       
        xtc = xtU+xtL
        Cd = Cf15_15 + (Cf60_100-Cf15_15)*(xtc-0.3)/(1.6-0.3)
        return Cd
