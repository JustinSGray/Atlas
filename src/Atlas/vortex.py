# Autogenerated with SMOP version 0.22
# /Users/tahearn1/Documents/thearn_repos/OpenMDAO-Framework/devenv/bin/smop VortexWakeCover_c.m -o v2.py
from __future__ import division
import numpy as np
from numpy import pi, cos, sin, mean, linspace, sqrt
from scipy.io import loadmat,savemat
import os


yN = np.arange(11)
rho = 1.18
dT = np.array([0.0649, 1.5887, 6.8049, 11.2556, 15.7854, 19.8941, 23.2617,
               25.7216, 27.2537, 18.6446])
vc = 0
Omega = 1.0367
b = 2
h = 1.5
Nw = 8
Ntt = 3
Ntheta = 20
qh = np.array([0, -0.0179, -0.0427, -0.0727, -0.1049, -0.1331, -0.1445,
               -0.1247, -0.0789, -0.0181, 0.0480])
ycmax = 1.4656



Ns=max(yN.shape) - 1
dy=np.zeros(Ns)
yE=np.zeros(Ns)
for s in range(1,(Ns+1)):
    dy[(s-1)]=yN[(s + 1-1)] - yN[(s-1)]
    yE[(s-1)]=0.5 * (yN[(s-1)] + yN[(s + 1-1)])
R=yN[(Ns + 1-1)]
cr=0.5 * mean(dy)
dtheta=pi / Ntheta
thetaArray=linspace(0 + dtheta / 2,pi - dtheta / 2,Ntheta)
ring_Gamma=np.zeros((Nw + 1,Ns + 1))
ring_z=np.zeros((Nw + 1,Ns + 1))
ring_r=np.zeros((Nw + 1,Ns + 1))
ring_vz=np.zeros((Nw + 1,Ns + 1))
ring_vr=np.zeros((Nw + 1,Ns + 1))
vi=np.zeros((Ns,1))

# GammaBound=dT / (rho * (Omega * yE).dot(dy))
GammaBound = dT / (rho*(Omega*yE)*dy)


ring_Gamma[0,0]=- GammaBound[0]
for s in range(2,(Ns+1)):
    ring_Gamma[0,(s-1)]=GammaBound[(s - 1-1)] - GammaBound[(s-1)]
ring_Gamma[0,(Ns + 1-1)]=GammaBound[(Ns-1)]
ring_r[0,:]=yN
ring_z[0,:]=qh[:]

for t in range(1,(Nw+1)):
    for tt in range(1,(Ntt+1)):
        ring_vz=np.zeros((Nw + 1,Ns + 1))
        ring_vr=np.zeros((Nw + 1,Ns + 1))
        for i in range(1,(t+1)):
            for s in range(1,(Ns + 1+1)):
                for ii in range(1,(t+1)):
                    for ss in range(2,(Ns + 1+1)):
                        zr=ring_z[(ii-1),(ss-1)]
                        r=ring_r[(ii-1),(ss-1)]
                        zp=ring_z[(i-1),(s-1)]
                        yp=ring_r[(i-1),(s-1)]
                        M=ring_Gamma[(ii-1),(ss-1)] * r * dtheta / (2 * pi)
                        X2=(- r * sin(thetaArray)) ** 2
                        Y2=(yp - r * cos(thetaArray)) ** 2
                        Z2=(zp - zr) ** 2
                        Normal=sqrt(X2 + Y2 + Z2)
                        for iii in range(1,(max(thetaArray.shape)+1)):
                            if Normal[(iii-1)] < cr:
                                Normal[(iii-1)]=cr
                        Norm3=Normal ** 3
                        ring_vr[(i-1),(s-1)]=ring_vr[(i-1),(s-1)] + np.sum(- cos(thetaArray) * (zp - zr) / Norm3) * M
                        ring_vz[(i-1),(s-1)]=ring_vz[(i-1),(s-1)] + np.sum((cos(thetaArray) * yp - r) / Norm3) * M
                        zr=- 2 * h - ring_z[(ii-1),(ss-1)]
                        Z2=(zp - zr) ** 2
                        Normal=sqrt(X2 + Y2 + Z2)
                        for iii in range(1,(max(thetaArray.shape)+1)):
                            if Normal[(iii-1)] < cr:
                                Normal[(iii-1)]=cr
                        Norm3=Normal ** 3
                        ring_vr[(i-1),(s-1)]=ring_vr[(i-1),(s-1)] - np.sum(- cos(thetaArray) * (zp - zr) / Norm3) * M
                        ring_vz[(i-1),(s-1)]=ring_vz[(i-1),(s-1)] - np.sum((cos(thetaArray) * yp - r) / Norm3) * M

        if tt == 1:
            PiApprox=8 * np.sum(dT.dot(vi))
        realtime=2 * pi / Omega / b * ((t - 1) * Ntt + tt) / Ntt
        altitude=vc * realtime
        dt=2 * pi / Omega / b / Ntt

        for i in range(1,(t+1)):
            for s in range(1,(Ns + 1+1)):
                ring_z[(i-1),(s-1)]=ring_z[(i-1),(s-1)] + ring_vz[(i-1),(s-1)] * dt
                ring_r[(i-1),(s-1)]=ring_r[(i-1),(s-1)] + ring_vr[(i-1),(s-1)] * dt
                ring_Gamma[(i-1),(s-1)]=ring_Gamma[(i-1),(s-1)]
    for i in range(1, t+1)[::-1]:
        ring_Gamma[(i + 1-1),:]=ring_Gamma[(i-1),:]
        ring_r[(i + 1-1),:]=ring_r[(i-1),:]
        ring_z[(i + 1-1),:]=ring_z[(i-1),:]
    #GammaBound=dT / (rho * (Omega * yE).dot(dy))
    GammaBound = dT / (rho*(Omega*yE)*dy)
    ring_Gamma[0,0]=- GammaBound[0]
    for s in range(2,(Ns+1)):
        ring_Gamma[0,(s-1)]=GammaBound[(s - 1-1)] - GammaBound[(s-1)]
    ring_Gamma[0,(Ns + 1-1)]=GammaBound[(Ns-1)]
    ring_r[0,:]=yN
    ring_z[0,:]=qh[:]

for s in range(1,(Ns+1)):
    vi[(s-1)]=0
    for ii in range(1,(t+1)):
        for ss in range(2,(Ns + 1+1)):
            if (ii == 1):
                ringFrac=0.675
            else:
                ringFrac=1
            zr=ring_z[(ii-1),(ss-1)]
            r=ring_r[(ii-1),(ss-1)]
            zp=(qh[(s-1)] + qh[(s + 1-1)]) / 2
            yp=yE[(s-1)]
            M=ring_Gamma[(ii-1),(ss-1)] * r * dtheta / (2 * pi)
            X2=(- r * sin(thetaArray)) ** 2
            Y2=(yp - r * cos(thetaArray)) ** 2
            Z2=(zp - zr) ** 2
            Normal=sqrt(X2 + Y2 + Z2)
            for iii in range(1,(max(thetaArray.shape)+1)):
                if Normal[(iii-1)] < cr:
                    Normal[(iii-1)]=cr
            Norm3=Normal ** 3
            vi[(s-1)]=vi[(s-1)] + ringFrac * np.sum((cos(thetaArray) * yp - r) / Norm3) * M
            zr=- 2 * h - ring_z[(ii-1),(ss-1)]
            Z2=(zp - zr) ** 2
            Normal=sqrt(X2 + Y2 + Z2)
            for iii in range(1,(max(thetaArray.shape)+1)):
                if Normal[(iii-1)] < cr:
                    Normal[(iii-1)]=cr
            Norm3=Normal ** 3
            vi[(s-1)]=vi[(s-1)] - ringFrac * np.sum((cos(thetaArray) * yp - r) / Norm3) * M
vi=- vi
print vi

